// Generated by ScalaBuff, the Scala Protocol Buffers compiler. DO NOT EDIT!
// source: RemoteProtocol.proto

package resources.generated

final case class AkkaRemoteProtocol (
	`message`: Option[RemoteMessageProtocol] = None,
	`instruction`: Option[RemoteControlProtocol] = None
) extends com.google.protobuf.GeneratedMessageLite
	with net.sandrogrzicic.scalabuff.Message[AkkaRemoteProtocol] {

	def getMessage = `message`.getOrElse(RemoteMessageProtocol.defaultInstance)
	def getInstruction = `instruction`.getOrElse(RemoteControlProtocol.defaultInstance)

	def setMessage(_f: RemoteMessageProtocol) = copy(`message` = _f)
	def setInstruction(_f: RemoteControlProtocol) = copy(`instruction` = _f)

	def clearMessage = copy(`message` = None)
	def clearInstruction = copy(`instruction` = None)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		if (`message`.isDefined) output.writeMessage(1, `message`.get)
		if (`instruction`.isDefined) output.writeMessage(2, `instruction`.get)
	}

	lazy val getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var size = 0
		if (`message`.isDefined) size += computeMessageSize(1, `message`.get)
		if (`instruction`.isDefined) size += computeMessageSize(2, `instruction`.get)

		size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): AkkaRemoteProtocol = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __message: Option[RemoteMessageProtocol] = `message`
		var __instruction: Option[RemoteControlProtocol] = `instruction`

		def __newMerged = AkkaRemoteProtocol(
			__message,
			__instruction
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __message = readMessage[RemoteMessageProtocol](in, __message.orElse({
				__message = RemoteMessageProtocol.defaultInstance
				__message
			}).get, _emptyRegistry)
			case 18 => __instruction = readMessage[RemoteControlProtocol](in, __instruction.orElse({
				__instruction = RemoteControlProtocol.defaultInstance
				__instruction
			}).get, _emptyRegistry)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: AkkaRemoteProtocol) = {
		AkkaRemoteProtocol(
			m.`message`.orElse(`message`),
			m.`instruction`.orElse(`instruction`)
		)
	}

	def getDefaultInstanceForType = AkkaRemoteProtocol.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def newBuilderForType = this
	def toBuilder = this
}

object AkkaRemoteProtocol {
	@reflect.BeanProperty val defaultInstance = new AkkaRemoteProtocol()

	val MESSAGE_FIELD_NUMBER = 1
	val INSTRUCTION_FIELD_NUMBER = 2

}
final case class RemoteMessageProtocol (
	`uuid`: UuidProtocol = UuidProtocol.defaultInstance,
	`actorInfo`: ActorInfoProtocol = ActorInfoProtocol.defaultInstance,
	`oneWay`: Boolean = false,
	`message`: Option[MessageProtocol] = None,
	`exception`: Option[ExceptionProtocol] = None,
	`supervisorUuid`: Option[UuidProtocol] = None,
	`sender`: Option[RemoteActorRefProtocol] = None,
	`metadata`: Vector[MetadataEntryProtocol] = Vector.empty[MetadataEntryProtocol]
) extends com.google.protobuf.GeneratedMessageLite
	with net.sandrogrzicic.scalabuff.Message[RemoteMessageProtocol] {

	def getMessage = `message`.getOrElse(MessageProtocol.defaultInstance)
	def getException = `exception`.getOrElse(ExceptionProtocol.defaultInstance)
	def getSupervisorUuid = `supervisorUuid`.getOrElse(UuidProtocol.defaultInstance)
	def getSender = `sender`.getOrElse(RemoteActorRefProtocol.defaultInstance)

	def setMessage(_f: MessageProtocol) = copy(`message` = _f)
	def setException(_f: ExceptionProtocol) = copy(`exception` = _f)
	def setSupervisorUuid(_f: UuidProtocol) = copy(`supervisorUuid` = _f)
	def setSender(_f: RemoteActorRefProtocol) = copy(`sender` = _f)
	def setMetadata(_i: Int, _v: MetadataEntryProtocol) = copy(`metadata` = `metadata`.updated(_i, _v))
	def addMetadata(_f: MetadataEntryProtocol) = copy(`metadata` = `metadata` :+ _f)
	def addAllMetadata(_f: MetadataEntryProtocol*) = copy(`metadata` = `metadata` ++ _f)
	def addAllMetadata(_f: TraversableOnce[MetadataEntryProtocol]) = copy(`metadata` = `metadata` ++ _f)

	def clearUuid = copy(`uuid` = UuidProtocol.defaultInstance)
	def clearActorInfo = copy(`actorInfo` = ActorInfoProtocol.defaultInstance)
	def clearOneWay = copy(`oneWay` = false)
	def clearMessage = copy(`message` = None)
	def clearException = copy(`exception` = None)
	def clearSupervisorUuid = copy(`supervisorUuid` = None)
	def clearSender = copy(`sender` = None)
	def clearMetadata = copy(`metadata` = Vector.empty[MetadataEntryProtocol])

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeMessage(1, `uuid`)
		output.writeMessage(2, `actorInfo`)
		output.writeBool(3, `oneWay`)
		if (`message`.isDefined) output.writeMessage(4, `message`.get)
		if (`exception`.isDefined) output.writeMessage(5, `exception`.get)
		if (`supervisorUuid`.isDefined) output.writeMessage(6, `supervisorUuid`.get)
		if (`sender`.isDefined) output.writeMessage(7, `sender`.get)
		for (_v <- `metadata`) output.writeMessage(8, _v)
	}

	lazy val getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var size = 0
		size += computeMessageSize(1, `uuid`)
		size += computeMessageSize(2, `actorInfo`)
		size += computeBoolSize(3, `oneWay`)
		if (`message`.isDefined) size += computeMessageSize(4, `message`.get)
		if (`exception`.isDefined) size += computeMessageSize(5, `exception`.get)
		if (`supervisorUuid`.isDefined) size += computeMessageSize(6, `supervisorUuid`.get)
		if (`sender`.isDefined) size += computeMessageSize(7, `sender`.get)
		for (_v <- `metadata`) size += computeMessageSize(8, _v)

		size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RemoteMessageProtocol = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __uuid: UuidProtocol = UuidProtocol.defaultInstance
		var __actorInfo: ActorInfoProtocol = ActorInfoProtocol.defaultInstance
		var __oneWay: Boolean = false
		var __message: Option[MessageProtocol] = `message`
		var __exception: Option[ExceptionProtocol] = `exception`
		var __supervisorUuid: Option[UuidProtocol] = `supervisorUuid`
		var __sender: Option[RemoteActorRefProtocol] = `sender`
		val __metadata: collection.mutable.Buffer[MetadataEntryProtocol] = `metadata`.toBuffer

		def __newMerged = RemoteMessageProtocol(
			__uuid,
			__actorInfo,
			__oneWay,
			__message,
			__exception,
			__supervisorUuid,
			__sender,
			Vector(__metadata: _*)
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __uuid = readMessage[UuidProtocol](in, __uuid, _emptyRegistry)
			case 18 => __actorInfo = readMessage[ActorInfoProtocol](in, __actorInfo, _emptyRegistry)
			case 24 => __oneWay = in.readBool()
			case 34 => __message = readMessage[MessageProtocol](in, __message.orElse({
				__message = MessageProtocol.defaultInstance
				__message
			}).get, _emptyRegistry)
			case 42 => __exception = readMessage[ExceptionProtocol](in, __exception.orElse({
				__exception = ExceptionProtocol.defaultInstance
				__exception
			}).get, _emptyRegistry)
			case 50 => __supervisorUuid = readMessage[UuidProtocol](in, __supervisorUuid.orElse({
				__supervisorUuid = UuidProtocol.defaultInstance
				__supervisorUuid
			}).get, _emptyRegistry)
			case 58 => __sender = readMessage[RemoteActorRefProtocol](in, __sender.orElse({
				__sender = RemoteActorRefProtocol.defaultInstance
				__sender
			}).get, _emptyRegistry)
			case 66 => __metadata += readMessage[MetadataEntryProtocol](in, MetadataEntryProtocol.defaultInstance, _emptyRegistry)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: RemoteMessageProtocol) = {
		RemoteMessageProtocol(
			m.`uuid`,
			m.`actorInfo`,
			m.`oneWay`,
			m.`message`.orElse(`message`),
			m.`exception`.orElse(`exception`),
			m.`supervisorUuid`.orElse(`supervisorUuid`),
			m.`sender`.orElse(`sender`),
			`metadata` ++ m.`metadata`
		)
	}

	def getDefaultInstanceForType = RemoteMessageProtocol.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def newBuilderForType = this
	def toBuilder = this
}

object RemoteMessageProtocol {
	@reflect.BeanProperty val defaultInstance = new RemoteMessageProtocol()

	val UUID_FIELD_NUMBER = 1
	val ACTORINFO_FIELD_NUMBER = 2
	val ONEWAY_FIELD_NUMBER = 3
	val MESSAGE_FIELD_NUMBER = 4
	val EXCEPTION_FIELD_NUMBER = 5
	val SUPERVISORUUID_FIELD_NUMBER = 6
	val SENDER_FIELD_NUMBER = 7
	val METADATA_FIELD_NUMBER = 8

}
final case class RemoteControlProtocol (
	`cookie`: Option[String] = None,
	`commandType`: CommandType.EnumVal = CommandType._UNINITIALIZED
) extends com.google.protobuf.GeneratedMessageLite
	with net.sandrogrzicic.scalabuff.Message[RemoteControlProtocol] {

	def getCookie = `cookie`.getOrElse("")

	def setCookie(_f: String) = copy(`cookie` = _f)

	def clearCookie = copy(`cookie` = None)
	def clearCommandType = copy(`commandType` = CommandType._UNINITIALIZED)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		if (`cookie`.isDefined) output.writeString(1, `cookie`.get)
		output.writeEnum(2, `commandType`)
	}

	lazy val getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var size = 0
		if (`cookie`.isDefined) size += computeStringSize(1, `cookie`.get)
		size += computeEnumSize(2, `commandType`)

		size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RemoteControlProtocol = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __cookie: Option[String] = `cookie`
		var __commandType: CommandType.EnumVal = CommandType._UNINITIALIZED

		def __newMerged = RemoteControlProtocol(
			__cookie,
			__commandType
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __cookie = in.readString()
			case 16 => __commandType = CommandType.valueOf(in.readEnum())
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: RemoteControlProtocol) = {
		RemoteControlProtocol(
			m.`cookie`.orElse(`cookie`),
			m.`commandType`
		)
	}

	def getDefaultInstanceForType = RemoteControlProtocol.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def newBuilderForType = this
	def toBuilder = this
}

object RemoteControlProtocol {
	@reflect.BeanProperty val defaultInstance = new RemoteControlProtocol()

	val COOKIE_FIELD_NUMBER = 1
	val COMMANDTYPE_FIELD_NUMBER = 2

}
object CommandType extends net.sandrogrzicic.scalabuff.Enum {
	sealed trait EnumVal extends Value
	val _UNINITIALIZED = new EnumVal { val name = "UNINITIALIZED ENUM VALUE"; val id = -1 }

	val CONNECT = new EnumVal { val name = "CONNECT"; val id = 1 }
	val SHUTDOWN = new EnumVal { val name = "SHUTDOWN"; val id = 2 }

	val CONNECT_VALUE = 1
	val SHUTDOWN_VALUE = 2

	def valueOf(id: Int) = id match {
		case 1 => CONNECT
		case 2 => SHUTDOWN
		case _default => throw new net.sandrogrzicic.scalabuff.UnknownEnumException(_default)
	}
	val internalGetValueMap = new com.google.protobuf.Internal.EnumLiteMap[EnumVal] {
		def findValueByNumber(id: Int): EnumVal = valueOf(id)
	}
}
object ReplicationStorageType extends net.sandrogrzicic.scalabuff.Enum {
	sealed trait EnumVal extends Value
	val _UNINITIALIZED = new EnumVal { val name = "UNINITIALIZED ENUM VALUE"; val id = -1 }

	val TRANSIENT = new EnumVal { val name = "TRANSIENT"; val id = 1 }
	val TRANSACTION_LOG = new EnumVal { val name = "TRANSACTION_LOG"; val id = 2 }
	val DATA_GRID = new EnumVal { val name = "DATA_GRID"; val id = 3 }

	val TRANSIENT_VALUE = 1
	val TRANSACTION_LOG_VALUE = 2
	val DATA_GRID_VALUE = 3

	def valueOf(id: Int) = id match {
		case 1 => TRANSIENT
		case 2 => TRANSACTION_LOG
		case 3 => DATA_GRID
		case _default => throw new net.sandrogrzicic.scalabuff.UnknownEnumException(_default)
	}
	val internalGetValueMap = new com.google.protobuf.Internal.EnumLiteMap[EnumVal] {
		def findValueByNumber(id: Int): EnumVal = valueOf(id)
	}
}
object ReplicationStrategyType extends net.sandrogrzicic.scalabuff.Enum {
	sealed trait EnumVal extends Value
	val _UNINITIALIZED = new EnumVal { val name = "UNINITIALIZED ENUM VALUE"; val id = -1 }

	val WRITE_THROUGH = new EnumVal { val name = "WRITE_THROUGH"; val id = 1 }
	val WRITE_BEHIND = new EnumVal { val name = "WRITE_BEHIND"; val id = 2 }

	val WRITE_THROUGH_VALUE = 1
	val WRITE_BEHIND_VALUE = 2

	def valueOf(id: Int) = id match {
		case 1 => WRITE_THROUGH
		case 2 => WRITE_BEHIND
		case _default => throw new net.sandrogrzicic.scalabuff.UnknownEnumException(_default)
	}
	val internalGetValueMap = new com.google.protobuf.Internal.EnumLiteMap[EnumVal] {
		def findValueByNumber(id: Int): EnumVal = valueOf(id)
	}
}
final case class RemoteActorRefProtocol (
	`address`: String = "",
	`inetSocketAddress`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
	`timeout`: Option[Long] = None
) extends com.google.protobuf.GeneratedMessageLite
	with net.sandrogrzicic.scalabuff.Message[RemoteActorRefProtocol] {

	def getTimeout = `timeout`.getOrElse(0L)

	def setTimeout(_f: Long) = copy(`timeout` = _f)

	def clearAddress = copy(`address` = "")
	def clearInetSocketAddress = copy(`inetSocketAddress` = com.google.protobuf.ByteString.EMPTY)
	def clearTimeout = copy(`timeout` = None)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeString(1, `address`)
		output.writeBytes(2, `inetSocketAddress`)
		if (`timeout`.isDefined) output.writeUInt64(3, `timeout`.get)
	}

	lazy val getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var size = 0
		size += computeStringSize(1, `address`)
		size += computeBytesSize(2, `inetSocketAddress`)
		if (`timeout`.isDefined) size += computeUInt64Size(3, `timeout`.get)

		size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RemoteActorRefProtocol = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __address: String = ""
		var __inetSocketAddress: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
		var __timeout: Option[Long] = `timeout`

		def __newMerged = RemoteActorRefProtocol(
			__address,
			__inetSocketAddress,
			__timeout
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __address = in.readString()
			case 18 => __inetSocketAddress = in.readBytes()
			case 24 => __timeout = in.readUInt64()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: RemoteActorRefProtocol) = {
		RemoteActorRefProtocol(
			m.`address`,
			m.`inetSocketAddress`,
			m.`timeout`.orElse(`timeout`)
		)
	}

	def getDefaultInstanceForType = RemoteActorRefProtocol.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def newBuilderForType = this
	def toBuilder = this
}

object RemoteActorRefProtocol {
	@reflect.BeanProperty val defaultInstance = new RemoteActorRefProtocol()

	val ADDRESS_FIELD_NUMBER = 1
	val INETSOCKETADDRESS_FIELD_NUMBER = 2
	val TIMEOUT_FIELD_NUMBER = 3

}
final case class SerializedActorRefProtocol (
	`uuid`: UuidProtocol = UuidProtocol.defaultInstance,
	`address`: String = "",
	`actorClassname`: String = "",
	`actorInstance`: Option[com.google.protobuf.ByteString] = None,
	`serializerClassname`: Option[String] = None,
	`timeout`: Option[Long] = None,
	`receiveTimeout`: Option[Long] = None,
	`lifeCycle`: Option[LifeCycleProtocol] = None,
	`supervisor`: Option[RemoteActorRefProtocol] = None,
	`hotswapStack`: Option[com.google.protobuf.ByteString] = None,
	`replicationStorage`: Option[ReplicationStorageType.EnumVal] = None,
	`replicationStrategy`: Option[ReplicationStrategyType.EnumVal] = None,
	`messages`: Vector[RemoteMessageProtocol] = Vector.empty[RemoteMessageProtocol]
) extends com.google.protobuf.GeneratedMessageLite
	with net.sandrogrzicic.scalabuff.Message[SerializedActorRefProtocol] {

	def getActorInstance = `actorInstance`.getOrElse(com.google.protobuf.ByteString.EMPTY)
	def getSerializerClassname = `serializerClassname`.getOrElse("")
	def getTimeout = `timeout`.getOrElse(0L)
	def getReceiveTimeout = `receiveTimeout`.getOrElse(0L)
	def getLifeCycle = `lifeCycle`.getOrElse(LifeCycleProtocol.defaultInstance)
	def getSupervisor = `supervisor`.getOrElse(RemoteActorRefProtocol.defaultInstance)
	def getHotswapStack = `hotswapStack`.getOrElse(com.google.protobuf.ByteString.EMPTY)

	def setActorInstance(_f: com.google.protobuf.ByteString) = copy(`actorInstance` = _f)
	def setSerializerClassname(_f: String) = copy(`serializerClassname` = _f)
	def setTimeout(_f: Long) = copy(`timeout` = _f)
	def setReceiveTimeout(_f: Long) = copy(`receiveTimeout` = _f)
	def setLifeCycle(_f: LifeCycleProtocol) = copy(`lifeCycle` = _f)
	def setSupervisor(_f: RemoteActorRefProtocol) = copy(`supervisor` = _f)
	def setHotswapStack(_f: com.google.protobuf.ByteString) = copy(`hotswapStack` = _f)
	def setReplicationStorage(_f: ReplicationStorageType.EnumVal) = copy(`replicationStorage` = _f)
	def setReplicationStrategy(_f: ReplicationStrategyType.EnumVal) = copy(`replicationStrategy` = _f)
	def setMessages(_i: Int, _v: RemoteMessageProtocol) = copy(`messages` = `messages`.updated(_i, _v))
	def addMessages(_f: RemoteMessageProtocol) = copy(`messages` = `messages` :+ _f)
	def addAllMessages(_f: RemoteMessageProtocol*) = copy(`messages` = `messages` ++ _f)
	def addAllMessages(_f: TraversableOnce[RemoteMessageProtocol]) = copy(`messages` = `messages` ++ _f)

	def clearUuid = copy(`uuid` = UuidProtocol.defaultInstance)
	def clearAddress = copy(`address` = "")
	def clearActorClassname = copy(`actorClassname` = "")
	def clearActorInstance = copy(`actorInstance` = None)
	def clearSerializerClassname = copy(`serializerClassname` = None)
	def clearTimeout = copy(`timeout` = None)
	def clearReceiveTimeout = copy(`receiveTimeout` = None)
	def clearLifeCycle = copy(`lifeCycle` = None)
	def clearSupervisor = copy(`supervisor` = None)
	def clearHotswapStack = copy(`hotswapStack` = None)
	def clearReplicationStorage = copy(`replicationStorage` = None)
	def clearReplicationStrategy = copy(`replicationStrategy` = None)
	def clearMessages = copy(`messages` = Vector.empty[RemoteMessageProtocol])

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeMessage(1, `uuid`)
		output.writeString(2, `address`)
		output.writeString(3, `actorClassname`)
		if (`actorInstance`.isDefined) output.writeBytes(4, `actorInstance`.get)
		if (`serializerClassname`.isDefined) output.writeString(5, `serializerClassname`.get)
		if (`timeout`.isDefined) output.writeUInt64(6, `timeout`.get)
		if (`receiveTimeout`.isDefined) output.writeUInt64(7, `receiveTimeout`.get)
		if (`lifeCycle`.isDefined) output.writeMessage(8, `lifeCycle`.get)
		if (`supervisor`.isDefined) output.writeMessage(9, `supervisor`.get)
		if (`hotswapStack`.isDefined) output.writeBytes(10, `hotswapStack`.get)
		if (`replicationStorage`.isDefined) output.writeEnum(11, `replicationStorage`.get)
		if (`replicationStrategy`.isDefined) output.writeEnum(12, `replicationStrategy`.get)
		for (_v <- `messages`) output.writeMessage(13, _v)
	}

	lazy val getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var size = 0
		size += computeMessageSize(1, `uuid`)
		size += computeStringSize(2, `address`)
		size += computeStringSize(3, `actorClassname`)
		if (`actorInstance`.isDefined) size += computeBytesSize(4, `actorInstance`.get)
		if (`serializerClassname`.isDefined) size += computeStringSize(5, `serializerClassname`.get)
		if (`timeout`.isDefined) size += computeUInt64Size(6, `timeout`.get)
		if (`receiveTimeout`.isDefined) size += computeUInt64Size(7, `receiveTimeout`.get)
		if (`lifeCycle`.isDefined) size += computeMessageSize(8, `lifeCycle`.get)
		if (`supervisor`.isDefined) size += computeMessageSize(9, `supervisor`.get)
		if (`hotswapStack`.isDefined) size += computeBytesSize(10, `hotswapStack`.get)
		if (`replicationStorage`.isDefined) size += computeEnumSize(11, `replicationStorage`.get)
		if (`replicationStrategy`.isDefined) size += computeEnumSize(12, `replicationStrategy`.get)
		for (_v <- `messages`) size += computeMessageSize(13, _v)

		size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): SerializedActorRefProtocol = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __uuid: UuidProtocol = UuidProtocol.defaultInstance
		var __address: String = ""
		var __actorClassname: String = ""
		var __actorInstance: Option[com.google.protobuf.ByteString] = `actorInstance`
		var __serializerClassname: Option[String] = `serializerClassname`
		var __timeout: Option[Long] = `timeout`
		var __receiveTimeout: Option[Long] = `receiveTimeout`
		var __lifeCycle: Option[LifeCycleProtocol] = `lifeCycle`
		var __supervisor: Option[RemoteActorRefProtocol] = `supervisor`
		var __hotswapStack: Option[com.google.protobuf.ByteString] = `hotswapStack`
		var __replicationStorage: Option[ReplicationStorageType.EnumVal] = `replicationStorage`
		var __replicationStrategy: Option[ReplicationStrategyType.EnumVal] = `replicationStrategy`
		val __messages: collection.mutable.Buffer[RemoteMessageProtocol] = `messages`.toBuffer

		def __newMerged = SerializedActorRefProtocol(
			__uuid,
			__address,
			__actorClassname,
			__actorInstance,
			__serializerClassname,
			__timeout,
			__receiveTimeout,
			__lifeCycle,
			__supervisor,
			__hotswapStack,
			__replicationStorage,
			__replicationStrategy,
			Vector(__messages: _*)
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __uuid = readMessage[UuidProtocol](in, __uuid, _emptyRegistry)
			case 18 => __address = in.readString()
			case 26 => __actorClassname = in.readString()
			case 34 => __actorInstance = in.readBytes()
			case 42 => __serializerClassname = in.readString()
			case 48 => __timeout = in.readUInt64()
			case 56 => __receiveTimeout = in.readUInt64()
			case 66 => __lifeCycle = readMessage[LifeCycleProtocol](in, __lifeCycle.orElse({
				__lifeCycle = LifeCycleProtocol.defaultInstance
				__lifeCycle
			}).get, _emptyRegistry)
			case 74 => __supervisor = readMessage[RemoteActorRefProtocol](in, __supervisor.orElse({
				__supervisor = RemoteActorRefProtocol.defaultInstance
				__supervisor
			}).get, _emptyRegistry)
			case 82 => __hotswapStack = in.readBytes()
			case 88 => __replicationStorage = ReplicationStorageType.valueOf(in.readEnum())
			case 96 => __replicationStrategy = ReplicationStrategyType.valueOf(in.readEnum())
			case 106 => __messages += readMessage[RemoteMessageProtocol](in, RemoteMessageProtocol.defaultInstance, _emptyRegistry)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: SerializedActorRefProtocol) = {
		SerializedActorRefProtocol(
			m.`uuid`,
			m.`address`,
			m.`actorClassname`,
			m.`actorInstance`.orElse(`actorInstance`),
			m.`serializerClassname`.orElse(`serializerClassname`),
			m.`timeout`.orElse(`timeout`),
			m.`receiveTimeout`.orElse(`receiveTimeout`),
			m.`lifeCycle`.orElse(`lifeCycle`),
			m.`supervisor`.orElse(`supervisor`),
			m.`hotswapStack`.orElse(`hotswapStack`),
			m.`replicationStorage`.orElse(`replicationStorage`),
			m.`replicationStrategy`.orElse(`replicationStrategy`),
			`messages` ++ m.`messages`
		)
	}

	def getDefaultInstanceForType = SerializedActorRefProtocol.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def newBuilderForType = this
	def toBuilder = this
}

object SerializedActorRefProtocol {
	@reflect.BeanProperty val defaultInstance = new SerializedActorRefProtocol()

	val UUID_FIELD_NUMBER = 1
	val ADDRESS_FIELD_NUMBER = 2
	val ACTORCLASSNAME_FIELD_NUMBER = 3
	val ACTORINSTANCE_FIELD_NUMBER = 4
	val SERIALIZERCLASSNAME_FIELD_NUMBER = 5
	val TIMEOUT_FIELD_NUMBER = 6
	val RECEIVETIMEOUT_FIELD_NUMBER = 7
	val LIFECYCLE_FIELD_NUMBER = 8
	val SUPERVISOR_FIELD_NUMBER = 9
	val HOTSWAPSTACK_FIELD_NUMBER = 10
	val REPLICATIONSTORAGE_FIELD_NUMBER = 11
	val REPLICATIONSTRATEGY_FIELD_NUMBER = 12
	val MESSAGES_FIELD_NUMBER = 13

}
final case class SerializedTypedActorRefProtocol (
	`actorRef`: SerializedActorRefProtocol = SerializedActorRefProtocol.defaultInstance,
	`interfaceName`: String = ""
) extends com.google.protobuf.GeneratedMessageLite
	with net.sandrogrzicic.scalabuff.Message[SerializedTypedActorRefProtocol] {



	def clearActorRef = copy(`actorRef` = SerializedActorRefProtocol.defaultInstance)
	def clearInterfaceName = copy(`interfaceName` = "")

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeMessage(1, `actorRef`)
		output.writeString(2, `interfaceName`)
	}

	lazy val getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var size = 0
		size += computeMessageSize(1, `actorRef`)
		size += computeStringSize(2, `interfaceName`)

		size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): SerializedTypedActorRefProtocol = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __actorRef: SerializedActorRefProtocol = SerializedActorRefProtocol.defaultInstance
		var __interfaceName: String = ""

		def __newMerged = SerializedTypedActorRefProtocol(
			__actorRef,
			__interfaceName
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __actorRef = readMessage[SerializedActorRefProtocol](in, __actorRef, _emptyRegistry)
			case 18 => __interfaceName = in.readString()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: SerializedTypedActorRefProtocol) = {
		SerializedTypedActorRefProtocol(
			m.`actorRef`,
			m.`interfaceName`
		)
	}

	def getDefaultInstanceForType = SerializedTypedActorRefProtocol.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def newBuilderForType = this
	def toBuilder = this
}

object SerializedTypedActorRefProtocol {
	@reflect.BeanProperty val defaultInstance = new SerializedTypedActorRefProtocol()

	val ACTORREF_FIELD_NUMBER = 1
	val INTERFACENAME_FIELD_NUMBER = 2

}
final case class MessageProtocol (
	`message`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
	`messageManifest`: Option[com.google.protobuf.ByteString] = None
) extends com.google.protobuf.GeneratedMessageLite
	with net.sandrogrzicic.scalabuff.Message[MessageProtocol] {

	def getMessageManifest = `messageManifest`.getOrElse(com.google.protobuf.ByteString.EMPTY)

	def setMessageManifest(_f: com.google.protobuf.ByteString) = copy(`messageManifest` = _f)

	def clearMessage = copy(`message` = com.google.protobuf.ByteString.EMPTY)
	def clearMessageManifest = copy(`messageManifest` = None)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeBytes(1, `message`)
		if (`messageManifest`.isDefined) output.writeBytes(2, `messageManifest`.get)
	}

	lazy val getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var size = 0
		size += computeBytesSize(1, `message`)
		if (`messageManifest`.isDefined) size += computeBytesSize(2, `messageManifest`.get)

		size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): MessageProtocol = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __message: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
		var __messageManifest: Option[com.google.protobuf.ByteString] = `messageManifest`

		def __newMerged = MessageProtocol(
			__message,
			__messageManifest
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __message = in.readBytes()
			case 18 => __messageManifest = in.readBytes()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: MessageProtocol) = {
		MessageProtocol(
			m.`message`,
			m.`messageManifest`.orElse(`messageManifest`)
		)
	}

	def getDefaultInstanceForType = MessageProtocol.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def newBuilderForType = this
	def toBuilder = this
}

object MessageProtocol {
	@reflect.BeanProperty val defaultInstance = new MessageProtocol()

	val MESSAGE_FIELD_NUMBER = 1
	val MESSAGEMANIFEST_FIELD_NUMBER = 2

}
final case class ActorInfoProtocol (
	`uuid`: UuidProtocol = UuidProtocol.defaultInstance,
	`timeout`: Long = 0L,
	`address`: Option[String] = None
) extends com.google.protobuf.GeneratedMessageLite
	with net.sandrogrzicic.scalabuff.Message[ActorInfoProtocol] {

	def getAddress = `address`.getOrElse("")

	def setAddress(_f: String) = copy(`address` = _f)

	def clearUuid = copy(`uuid` = UuidProtocol.defaultInstance)
	def clearTimeout = copy(`timeout` = 0L)
	def clearAddress = copy(`address` = None)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeMessage(1, `uuid`)
		output.writeUInt64(2, `timeout`)
		if (`address`.isDefined) output.writeString(3, `address`.get)
	}

	lazy val getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var size = 0
		size += computeMessageSize(1, `uuid`)
		size += computeUInt64Size(2, `timeout`)
		if (`address`.isDefined) size += computeStringSize(3, `address`.get)

		size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): ActorInfoProtocol = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __uuid: UuidProtocol = UuidProtocol.defaultInstance
		var __timeout: Long = 0L
		var __address: Option[String] = `address`

		def __newMerged = ActorInfoProtocol(
			__uuid,
			__timeout,
			__address
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __uuid = readMessage[UuidProtocol](in, __uuid, _emptyRegistry)
			case 16 => __timeout = in.readUInt64()
			case 26 => __address = in.readString()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: ActorInfoProtocol) = {
		ActorInfoProtocol(
			m.`uuid`,
			m.`timeout`,
			m.`address`.orElse(`address`)
		)
	}

	def getDefaultInstanceForType = ActorInfoProtocol.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def newBuilderForType = this
	def toBuilder = this
}

object ActorInfoProtocol {
	@reflect.BeanProperty val defaultInstance = new ActorInfoProtocol()

	val UUID_FIELD_NUMBER = 1
	val TIMEOUT_FIELD_NUMBER = 2
	val ADDRESS_FIELD_NUMBER = 3

}
final case class UuidProtocol (
	`high`: Long = 0L,
	`low`: Long = 0L
) extends com.google.protobuf.GeneratedMessageLite
	with net.sandrogrzicic.scalabuff.Message[UuidProtocol] {



	def clearHigh = copy(`high` = 0L)
	def clearLow = copy(`low` = 0L)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeUInt64(1, `high`)
		output.writeUInt64(2, `low`)
	}

	lazy val getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var size = 0
		size += computeUInt64Size(1, `high`)
		size += computeUInt64Size(2, `low`)

		size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): UuidProtocol = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __high: Long = 0L
		var __low: Long = 0L

		def __newMerged = UuidProtocol(
			__high,
			__low
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __high = in.readUInt64()
			case 16 => __low = in.readUInt64()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: UuidProtocol) = {
		UuidProtocol(
			m.`high`,
			m.`low`
		)
	}

	def getDefaultInstanceForType = UuidProtocol.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def newBuilderForType = this
	def toBuilder = this
}

object UuidProtocol {
	@reflect.BeanProperty val defaultInstance = new UuidProtocol()

	val HIGH_FIELD_NUMBER = 1
	val LOW_FIELD_NUMBER = 2

}
final case class MetadataEntryProtocol (
	`key`: String = "",
	`value`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
) extends com.google.protobuf.GeneratedMessageLite
	with net.sandrogrzicic.scalabuff.Message[MetadataEntryProtocol] {



	def clearKey = copy(`key` = "")
	def clearValue = copy(`value` = com.google.protobuf.ByteString.EMPTY)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeString(1, `key`)
		output.writeBytes(2, `value`)
	}

	lazy val getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var size = 0
		size += computeStringSize(1, `key`)
		size += computeBytesSize(2, `value`)

		size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): MetadataEntryProtocol = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __key: String = ""
		var __value: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY

		def __newMerged = MetadataEntryProtocol(
			__key,
			__value
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __key = in.readString()
			case 18 => __value = in.readBytes()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: MetadataEntryProtocol) = {
		MetadataEntryProtocol(
			m.`key`,
			m.`value`
		)
	}

	def getDefaultInstanceForType = MetadataEntryProtocol.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def newBuilderForType = this
	def toBuilder = this
}

object MetadataEntryProtocol {
	@reflect.BeanProperty val defaultInstance = new MetadataEntryProtocol()

	val KEY_FIELD_NUMBER = 1
	val VALUE_FIELD_NUMBER = 2

}
object SerializationSchemeType extends net.sandrogrzicic.scalabuff.Enum {
	sealed trait EnumVal extends Value
	val _UNINITIALIZED = new EnumVal { val name = "UNINITIALIZED ENUM VALUE"; val id = -1 }

	val JAVA = new EnumVal { val name = "JAVA"; val id = 1 }
	val SBINARY = new EnumVal { val name = "SBINARY"; val id = 2 }
	val SCALA_JSON = new EnumVal { val name = "SCALA_JSON"; val id = 3 }
	val JAVA_JSON = new EnumVal { val name = "JAVA_JSON"; val id = 4 }
	val PROTOBUF = new EnumVal { val name = "PROTOBUF"; val id = 5 }

	val JAVA_VALUE = 1
	val SBINARY_VALUE = 2
	val SCALA_JSON_VALUE = 3
	val JAVA_JSON_VALUE = 4
	val PROTOBUF_VALUE = 5

	def valueOf(id: Int) = id match {
		case 1 => JAVA
		case 2 => SBINARY
		case 3 => SCALA_JSON
		case 4 => JAVA_JSON
		case 5 => PROTOBUF
		case _default => throw new net.sandrogrzicic.scalabuff.UnknownEnumException(_default)
	}
	val internalGetValueMap = new com.google.protobuf.Internal.EnumLiteMap[EnumVal] {
		def findValueByNumber(id: Int): EnumVal = valueOf(id)
	}
}
object LifeCycleType extends net.sandrogrzicic.scalabuff.Enum {
	sealed trait EnumVal extends Value
	val _UNINITIALIZED = new EnumVal { val name = "UNINITIALIZED ENUM VALUE"; val id = -1 }

	val PERMANENT = new EnumVal { val name = "PERMANENT"; val id = 1 }
	val TEMPORARY = new EnumVal { val name = "TEMPORARY"; val id = 2 }

	val PERMANENT_VALUE = 1
	val TEMPORARY_VALUE = 2

	def valueOf(id: Int) = id match {
		case 1 => PERMANENT
		case 2 => TEMPORARY
		case _default => throw new net.sandrogrzicic.scalabuff.UnknownEnumException(_default)
	}
	val internalGetValueMap = new com.google.protobuf.Internal.EnumLiteMap[EnumVal] {
		def findValueByNumber(id: Int): EnumVal = valueOf(id)
	}
}
final case class LifeCycleProtocol (
	`lifeCycle`: LifeCycleType.EnumVal = LifeCycleType._UNINITIALIZED
) extends com.google.protobuf.GeneratedMessageLite
	with net.sandrogrzicic.scalabuff.Message[LifeCycleProtocol] {



	def clearLifeCycle = copy(`lifeCycle` = LifeCycleType._UNINITIALIZED)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeEnum(1, `lifeCycle`)
	}

	lazy val getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var size = 0
		size += computeEnumSize(1, `lifeCycle`)

		size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): LifeCycleProtocol = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __lifeCycle: LifeCycleType.EnumVal = LifeCycleType._UNINITIALIZED

		def __newMerged = LifeCycleProtocol(
			__lifeCycle
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __lifeCycle = LifeCycleType.valueOf(in.readEnum())
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: LifeCycleProtocol) = {
		LifeCycleProtocol(
			m.`lifeCycle`
		)
	}

	def getDefaultInstanceForType = LifeCycleProtocol.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def newBuilderForType = this
	def toBuilder = this
}

object LifeCycleProtocol {
	@reflect.BeanProperty val defaultInstance = new LifeCycleProtocol()

	val LIFECYCLE_FIELD_NUMBER = 1

}
final case class AddressProtocol (
	`hostname`: String = "",
	`port`: Int = 0
) extends com.google.protobuf.GeneratedMessageLite
	with net.sandrogrzicic.scalabuff.Message[AddressProtocol] {



	def clearHostname = copy(`hostname` = "")
	def clearPort = copy(`port` = 0)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeString(1, `hostname`)
		output.writeUInt32(2, `port`)
	}

	lazy val getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var size = 0
		size += computeStringSize(1, `hostname`)
		size += computeUInt32Size(2, `port`)

		size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): AddressProtocol = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __hostname: String = ""
		var __port: Int = 0

		def __newMerged = AddressProtocol(
			__hostname,
			__port
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __hostname = in.readString()
			case 16 => __port = in.readUInt32()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: AddressProtocol) = {
		AddressProtocol(
			m.`hostname`,
			m.`port`
		)
	}

	def getDefaultInstanceForType = AddressProtocol.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def newBuilderForType = this
	def toBuilder = this
}

object AddressProtocol {
	@reflect.BeanProperty val defaultInstance = new AddressProtocol()

	val HOSTNAME_FIELD_NUMBER = 1
	val PORT_FIELD_NUMBER = 2

}
final case class ExceptionProtocol (
	`classname`: String = "",
	`message`: String = ""
) extends com.google.protobuf.GeneratedMessageLite
	with net.sandrogrzicic.scalabuff.Message[ExceptionProtocol] {



	def clearClassname = copy(`classname` = "")
	def clearMessage = copy(`message` = "")

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeString(1, `classname`)
		output.writeString(2, `message`)
	}

	lazy val getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var size = 0
		size += computeStringSize(1, `classname`)
		size += computeStringSize(2, `message`)

		size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): ExceptionProtocol = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __classname: String = ""
		var __message: String = ""

		def __newMerged = ExceptionProtocol(
			__classname,
			__message
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __classname = in.readString()
			case 18 => __message = in.readString()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: ExceptionProtocol) = {
		ExceptionProtocol(
			m.`classname`,
			m.`message`
		)
	}

	def getDefaultInstanceForType = ExceptionProtocol.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def newBuilderForType = this
	def toBuilder = this
}

object ExceptionProtocol {
	@reflect.BeanProperty val defaultInstance = new ExceptionProtocol()

	val CLASSNAME_FIELD_NUMBER = 1
	val MESSAGE_FIELD_NUMBER = 2

}

object RemoteProtocol {
	def registerAllExtensions(registry: com.google.protobuf.ExtensionRegistryLite) {
	}

}
