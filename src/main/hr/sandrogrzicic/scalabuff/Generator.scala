package hr.sandrogrzicic.scalabuff

import collection.mutable.{ListBuffer, StringBuilder}
import annotation.tailrec

/**
 * Scala class generator.
 * @author Sandro Gržičić
 */

class Generator(sourceName: String) {
	implicit def buffString(string: String): BuffedString = new BuffedString(string)

	val imports = ListBuffer[String]()

	var packageName: String = ""
	var fileName: String = sourceName.takeUntilFirst('.').camelCase
	var parameters: String = ""


	/**
	 * Generates the Scala class code.
	 */
	def generate = {
		val o = StringBuilder.newBuilder
		o
			.append("// Generated by ScalaBuff, the Scala protocol buffer compiler. DO NOT EDIT!\n")
			.append("// source: ")
			.append(sourceName)
			.append("\n\n")

		if (!packageName.isEmpty)
			o
				.append("package ")
				.append(packageName)
				.append("\n\n")

		o
			.append("case class ")
			.append(sourceName.takeUntilLast('.').camelCase)
			.append("(")
			.append(parameters)
			.append(") {\n")

		o.append("}\n")

		o.mkString
	}
}


object Generator {

	/**
	 * Recursively traverse the tree, adding elements to the Scala class generator.
	 */
	@tailrec
	protected def generate(tree: List[Node], gen: Generator): ScalaClass = {

		tree match {
			// if the tree is empty, returned the generated scala class
			case Nil => ScalaClass(gen.generate, gen.packageName.replace('.', '/') + '/', gen.fileName)
			// else, build upon the Scala class generator and call generate() again with the tree tail
			case node :: tail => {
				var treeTail = tail
				node match {
					case Message(messageName, messageBody) =>
						for (messageNode <- messageBody) messageNode match {
							case Field(label, fieldType, name, number, fOptions) =>
							case EnumStatement(name, constants, options) =>
							case Message(name, body) => treeTail = tree // instead of generate() so @tailrec works
							case Extension(name, body) =>
							case Extensions(extensions) =>
							case Group(label, name, number, body) =>
							case Option(key, value) =>
							case _ => throw new UnexpectedNodeException(messageNode, node)
						}
					case Extension(name, body) =>
					case EnumStatement(name, constants, options) => {
						for (enumConstant <- constants) {
						}
						for (enumOption <- options) {
						}
					}
					case ImportStatement(name) => gen.imports += name
					case PackageStatement(name) => gen.packageName = name
					case Option(key, value) => key match {
						case "java_package" => gen.packageName = value
						case "scala_package" => gen.packageName = value
						case "java_outer_classname" => gen.fileName = value
						case "scala_outer_classname" => gen.fileName = value
					}
					case _ => throw new UnexpectedNodeException(node)
				}

				generate(treeTail, gen)
			}
		}
	}

	protected def newClass(sourceName: String) = new Generator(sourceName)

	/**
	 * Returns a valid Scala class from the specified tree and source name.
	 */
	def apply(tree: List[Node], sourceName: String) = {
		generate(tree, Generator.newClass(sourceName))
	}

}

/**
 * A generated Scala class. The path is relative.
 * @author Sandro Gržičić
 */
case class ScalaClass(body: String, path: String, file: String) {
	assert(path.endsWith("/"), "path must end with a /")
	assert(!file.isEmpty, "file name must not be empty")
	assert(!file.contains("/"), "file name must not contain a /")
}

/**
 * Thrown when a valid Scala class cannot be generated using the the tree returned from the Parser.
 */
class GenerationFailureException(message: String) extends RuntimeException(message)

/**
 * Thrown when a Node occurs in an unexpected location in the tree.
 */
class UnexpectedNodeException(node: Node, parentNode: Node = null) extends GenerationFailureException(
	"Unexpected child node " + node.toString + parentNode match {
		case null => ""
		case _ => "found in " + parentNode.toString
	}
)