package hr.sandrogrzicic.scalabuff

import collection.mutable.{ListBuffer, StringBuilder}

/**
 * Scala class generator.
 * @author Sandro Gržičić
 */

class Generator(sourceName: String) {
	implicit def buffString(string: String): BuffedString = new BuffedString(string)

	val imports = ListBuffer[String]()

	var packageName: String = ""
	var fileName: String = sourceName.takeUntilFirst('.').camelCase


	/**
	 * Generates the Scala class code.
	 */
	def generate = {
		val o = StringBuilder.newBuilder
		o
			.append("// Generated by ScalaBuff, the Scala protocol buffer compiler. DO NOT EDIT!\n")
			.append("// source: " + sourceName + "\n\n")

		if (!packageName.isEmpty)
			o.append("package " + packageName + ";\n\n")

		o.append("class " + sourceName.takeUntilLast('.').camelCase + " private {\n")

		o.append("}\n")

		o.mkString
	}
}


object Generator {

	/**
	 * Traverse the tree, adding elements to the Scala class generator.
	 */
	protected def generate(tree: List[Node], sourceName: String) = {
		val m = Generator.newClass(sourceName)

		for (node <- tree) {
			node match {
				case Message(messageName, messageBody) =>
					for (messageNode <- messageBody) messageNode match {
						case Field(label, fieldType, name, number, fOptions) =>
						case EnumStatement(name, constants, options) =>
						case Message(name, body) =>
						case Extension(name, body) =>
						case ListNode(extensions) =>
						case Group(label, name, number, body) =>
						case Option(key, value) =>
						case _ => throw new UnexpectedNodeException(messageNode, node)
					}
				case Extension(name, body) =>
				case EnumStatement(name, constants, options) => {
					for (enumConstant <- constants) {

					}
					for (enumOption <- options) {

					}
				}
				case ImportStatement(name) => m.imports += name
				case PackageStatement(name) => m.packageName = name
				case Option(key, value) => key match {
					case "java_package" => m.packageName = value
					case "scala_package" => m.packageName = value
					case "java_outer_classname" => m.fileName = value
					case "scala_outer_classname" => m.fileName = value
				}

                case _ => throw new UnexpectedNodeException(node)
			}
		}

		ScalaClass(m.generate, m.packageName.replace('.', '/') + '/', m.fileName)
	}

	protected def newClass(sourceName: String) = new Generator(sourceName)

	/**
	 * Returns a valid Scala class from the specified tree and source name.
	 */
	def apply(tree: List[Node], sourceName: String) = {
		generate(tree, sourceName)
	}

}

/**
 * A generated Scala class. The path is relative.
 * @author Sandro Gržičić
 */
case class ScalaClass(body: String, path: String, file: String) {
	assert(path.endsWith("/"), "path must end with a /")
	assert(!file.isEmpty, "file name must not be empty")
	assert(!file.contains("/"), "file name must not contain a /")
}

/**
 * Thrown when a valid Scala class cannot be generated using the the tree returned from the Parser.
 */
class GenerationFailureException(message: String) extends RuntimeException(message)

/**
 * Thrown when a Node occurs in an unexpected location in the tree.
 */
class UnexpectedNodeException(node: Node, parentNode: Node = null) extends GenerationFailureException(
	"Unexpected child node " + node.toString + parentNode match {
		case null => ""
		case _ => "found in " + parentNode.toString
	}
)